version: 'v0.0.0'
LabBook: null
SciViz:
  auth:
    mode: database
  pages:
    Sessions:
      route: /sessions
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 200
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                # Description
                Here is a sample view of all the sessions within the IBL public data set.
                Feel free to inspect our backend-optimized paging, sorting, and filtering
                built for scale.
                Also, to illustrate some of our other features, we've chosen to illustrate
                here deceased subjects with a **RED** font and *recent* sessions to be
                highlighted in **YELLOW**. 
            Sessions:
              route: /sessions_query
              x: 0
              y: 1
              height: 4
              width: 1
              type: table
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_acquisition, ibl_subject, ibl_ephys, ibl_analyses_behavior,
                             ibl_plotting_behavior):
                    sess_proj = ibl_acquisition.Session().aggr(
                        ibl_acquisition.SessionProject().proj(
                            'session_project', dummy2='"x"') * dj.U('dummy2'),
                        session_project='IFNULL(session_project, "unassigned")',
                        keep_all_rows=True
                    )
                    psych_curve = ibl_acquisition.Session().aggr(
                        ibl_plotting_behavior.SessionPsychCurve().proj(dummy='"x"') * dj.U('dummy'),
                        nplot='count(dummy)',
                        keep_all_rows=True)
                    ephys_data = ibl_acquisition.Session().aggr(
                        ibl_ephys.ProbeInsertion().proj(dummy3='"x"') * dj.U('dummy3'),
                        nprobe='count(dummy3)',
                        keep_all_rows=True)
                    trainingStatus = (
                        ibl_acquisition.Session().aggr(
                            ibl_analyses_behavior.SessionTrainingStatus().proj(dummy4='"x"') * dj.U('dummy4'),
                            keep_all_rows=True) *
                        ibl_acquisition.Session().aggr(
                            ibl_analyses_behavior.SessionTrainingStatus(),
                            training_status='training_status',
                            good_enough_for_brainwide_map='good_enough_for_brainwide_map',
                            keep_all_rows=True)
                        )
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)

                    q = (ibl_acquisition.Session * sess_proj * psych_curve * ephys_data * subj *
                         ibl_subject.SubjectLab * ibl_subject.SubjectUser * trainingStatus)
                    # need to revert to datajoint 0.12.9
                    q = q.proj(
                        ...,
                        # _sciviz_font='IF(death_date IS NOT NULL, "rgb(255, 0, 0)", NULL)', # deceased mice
                        # _sciviz_background='IF(session_start_time > "2020-09-01", "rgba(255, 255, 50, 0.16)", NULL)', # recent sessions
                        )
                    return dict(query=q, fetch_args=[])
    # Plots:
    #   route: /plots
    #   grids:
    #     grid1:
    #       type: fixed
    #       max_component_per_page: 20
    #       columns: 2
    #       row_height: 700
    #       components:
    #         component1:
    #           route: /plot1
    #           type: plot:plotly:stored_json
    #           x: 0
    #           y: 0
    #           height: 1
    #           width: 1
    #           restriction: >
    #             def restriction(**kwargs):
    #                 return dict(**kwargs, p_id=2)
    #           dj_query: >
    #             def dj_query(test_group1_simple):
    #                 PlotlyTable = test_group1_simple.PlotlyTable
    #                 return dict(query=PlotlyTable, fetch_args=['plot'])
    #         component2:
    #           type: markdown
    #           x: 1
    #           y: 0
    #           height: 1
    #           width: 1
    #           text: |
    #             # This is a plotly plot

    #             *Nice*

    #             ðŸ¤” yaml apparently allows emojis
    # Metadata:
    #   route: /metadata
    #   grids:
    #     grid2:
    #       type: fixed
    #       columns: 6
    #       row_height: 233
    #       components:
    #         comp:
    #           type: metadata
    #           route: /metadata1
    #           x: 1
    #           y: 1
    #           height: 1
    #           width: 1
    #           restriction: >
    #             def restriction(**kwargs):
    #                 return dict(**kwargs, b_id=19)
    #           dj_query: >
    #             def dj_query(test_group1_simple):
    #                 TableA, TableB = (test_group1_simple.TableA,
    #                                   test_group1_simple.TableB)
    #                 return dict(query=(TableA * TableB), fetch_args=[])
    #         desc:
    #           type: markdown
    #           x: 3
    #           y: 0
    #           height: 3
    #           width: 3
    #           text: |
    #             # This is a metadata component
    #             it is not very useful by itself but when combined with the dynamic
    #             component generator it can provide a useful description of what the other
    #             components are.
    Psychometric_Curves:
      route: /psychometric_curves
      grids:
        grid1:
          route: /psychometric_curves_restrictions
          type: dynamic
          columns: 3
          row_height: 600
          restriction: >
            def restriction(**kwargs):
                return dj.AndList([dict(**kwargs), "session_start_time > '2020-09-20'"])
          dj_query: >
            def dj_query(ibl_plotting_behavior):
                q = ibl_plotting_behavior.SessionPsychCurve.proj()
                return dict(query=q, fetch_args=[])
          # issue with how datetime is being interpreted when passed as qp
          component_templates:
            Metadata:
              route: /psychometric_curves_metadata
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    q = ibl_plotting_behavior.SessionPsychCurve.proj(
                      ...,
                      '-plotting_data',
                      '-fit_pars',
                      )
                    return dict(query=q, fetch_args=[])
            # comp1:
            #   route: /myPlot
            #   type: plot:plotly:stored_json
            #   restriction: >
            #     def restriction(**kwargs):
            #         return dict(**kwargs)
            #   dj_query: >
            #     def dj_query(test_group1_simple):
            #         MousePlots = test_group1_simple.MousePlots
            #         return dict(query=(MousePlots), fetch_args=['plot'])
