version: '0.0.0'
SciViz:
  auth:
    mode: database
  extra_components:
    config: |
      from pharus.component_interface import type_map, PlotPlotlyStoredjsonComponent

      class PlotPlotlyRemoveFirst(PlotPlotlyStoredjsonComponent):
          def dj_query_route(self):
              fetch_metadata = self.fetch_metadata
              plotly_json = (fetch_metadata['query'] & self.restriction).fetch1(
                  *fetch_metadata['fetch_args'])
              plotly_json['data'] = [plotly_json['data'][1]]
              return plotly_json

      type_map = dict({'plot:plotly:remove_first': PlotPlotlyRemoveFirst}, **type_map)
  pages:
    Home:
      route: /home
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 1500
          components:
            landing description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                # DataJointâ„¢ powered visualization that adapts to *your* workflows

                ![](https://images.squarespace-cdn.com/content/v1/60e5a50c0632d17c36f6b2d3/1638463454411-SMVPVS9EBPLU9T9T5YMN/unsplash-image-Pyut03Gn98w.jpg?format=1000w)

                ## Features

                - Visualization that can **keep up with changing needs** of your lab
                - Standardized YAML build specification providing a **Low-Code web application
                  design** experience
                - Transport-optimization by leveraging **client-side rendering** with
                  [React](https://reactjs.org/)
                - **Python+[DataJoint](https://www.datajoint.org/) interoperability** to allow
                  streamlined integration
                - Clear separation between business logic from product features i.e. **customization
                  through configuration**
                - **Backend-optimized** page rendering built for big-data and scale
                - Comprehensive permission and security design enabling **flexible access control**
                  modes

                ## Component Library Types

                - `page`: Unique tabbed pages to separate areas within your single-page application
                - `grid`: Layout structure for organizing subcomponents (as seen in
                  [Grafana, AWS Console](https://github.com/react-grid-layout/react-grid-layout#projects-using-react-grid-layout))
                  - `fixed`: For when you know exactly how many components you'd like to render
                  - `dynamic`: Component templating mode when you need to render realtime views that
                    vary in number of components
                - `table`: Sometimes there's nothing better than a table view
                  - paging
                  - sorting
                  - filtering
                  - font/backgrond highlighting
                - `metadata`: Great for showing context info for particular views
                - `plot`: Let's face it, we are going to need to be able to plot stuff
                  - plotly

                ## Acknowledgements

                We'd like to thank [internationalbrainlab.org](https://data.internationalbrainlab.org) for releasing
                publicly various sets of experimental workflow data. In order to provide a DEMO that
                seems more *relevant* we've used this public data to help grasp some of the concepts
                of what is currently supported in SciViz.
    Sessions:
      route: /sessions
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 275
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                ## Description

                Below is a summary of experimental session data from an acquisition system. The data
                set is certainly not in the realm of *big data* but there is sufficient records here
                to demonstrate the **backend-optimized** paging, sorting, and filtering. This is
                currently pointed to a live system so please feel free to try out the features and
                interact with the data.

                We've also configured font and background highlighting with the following rules:
                - Color the font in **RED** for the sessions where the subject is deceased.
                - Color the background in **YELLOW** if the session was started later than
                  `2020-09-01`.

                These rules along with configuring the backend query is entirely configurable
                using the standard spec file and DataJoint.

                Also, feel free to *click* below on a specific row of interest to be taken to a
                single-session, hidden page.
            Sessions:
              route: /sessions_query
              x: 0
              y: 1
              height: 4
              width: 1
              type: table
              link: /session
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_subject, ibl_acquisition):
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)
                    q = (ibl_acquisition.Session * subj).proj(
                        ...,
                        _sciviz_font='IF(death_date IS NOT NULL, "rgb(255, 0, 0)", NULL)', # deceased mice
                        _sciviz_background='IF(session_start_time > "2020-09-01", "rgba(255, 255, 50, 0.16)", NULL)', # recent sessions
                        )
                    return dict(query=q, fetch_args=[])
    Session:
      hidden: true
      route: /session
      grids:
        grid1:
          type: fixed
          columns: 2
          row_height: 250
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 2
              type: markdown
              text: |
                ## Description

                This is a hidden session page providing metadata and plotting details for an individual session.
                Restrictions are provided based on the primary key passed in as query parameters to the page's URL.
            session meta 1:
              route: /session_metadata1_query
              x: 0
              y: 1
              height: 1
              width: 1
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_subject, ibl_acquisition):
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)
                    q = (ibl_acquisition.Session * subj).proj('session_lab', 'task_protocol')
                    return dict(query=q, fetch_args=[])
            session meta 2:
              route: /session_metadata2_query
              x: 1
              y: 1
              height: 1
              width: 1
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_subject, ibl_acquisition):
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)
                    q = (ibl_acquisition.Session * subj).proj('subject_uuid', 'death_date')
                    return dict(query=q, fetch_args=[])
            Reaction time - trial number:
              route: /session_plot_query
              x: 2
              y: 0
              height: 2
              width: 2
              type: plot:plotly:remove_first
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    return dict(query=ibl_plotting_behavior.SessionReactionTimeTrialNumber, fetch_args=['plotting_data'])
    Psychometric Curves:
      route: /psychometric_curves
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 150
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                ## Description

                Let's suppose that you need a view to be more responsive to changing, realtime
                events. For instance, you'd like to see Psychometric curves for all newer
                sessions from 2 weeks ago (currently pinned to `2020-09-11`). This satisfies
                this by including both the metadata and the Psychometric curve for a given
                recent session.
        grid2:
          route: /psychometric_curves_restrictions
          type: dynamic
          columns: 2
          row_height: 500
          restriction: >
            def restriction(**kwargs):
                return dj.AndList([dict(**kwargs), "session_start_time > '2020-09-18'"])
          dj_query: >
            def dj_query(ibl_plotting_behavior):
                return dict(query=ibl_plotting_behavior.SessionPsychCurve.proj(), fetch_args=[])
          component_templates:
            Metadata:
              route: /psychometric_curves_metadata
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    q = ibl_plotting_behavior.SessionPsychCurve.proj(
                        ...,
                        '-plotting_data',
                        '-fit_pars',
                        )
                    return dict(query=q, fetch_args=[])
            Psychometric Plot:
              route: /psychometric_curves_plot
              type: plot:plotly:stored_json
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    return dict(query=ibl_plotting_behavior.SessionPsychCurve(), fetch_args=['plotting_data'])

